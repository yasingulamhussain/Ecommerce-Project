{"ast":null,"code":"// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\"); // src/utils/errors.ts\n\nvar errors = process.env.NODE_ENV !== \"production\" ? [// All error codes, starting by 0:\nfunction (plugin) {\n  return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n}, function (thing) {\n  return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n}, \"This object has been frozen and should not be mutated\", function (data) {\n  return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n}, \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\", \"Immer forbids circular references\", \"The first or second argument to `produce` must be a function\", \"The third argument to `produce` must be a function or undefined\", \"First argument to `createDraft` must be a plain object, an array, or an immerable object\", \"First argument to `finishDraft` must be a draft returned by `createDraft`\", function (thing) {\n  return `'current' expects a draft, got: ${thing}`;\n}, \"Object.defineProperty() cannot be used on an Immer draft\", \"Object.setPrototypeOf() cannot be used on an Immer draft\", \"Immer only supports deleting array indices\", \"Immer only supports setting array indices and the 'length' property\", function (thing) {\n  return `'original' expects a draft, got: ${thing}`;\n} // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n// See Patches.ts for additional errors\n] : [];\n\nfunction die(error) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const e = errors[error];\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    const msg = typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(`[Immer] ${msg}`);\n  }\n\n  throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);\n} // src/utils/common.ts\n\n\nvar getPrototypeOf = Object.getPrototypeOf;\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n\nfunction isDraftable(value) {\n  if (!value) return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\n\nvar objectCtorString = Object.prototype.constructor.toString();\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") return false;\n  const proto = getPrototypeOf(value);\n\n  if (proto === null) {\n    return true;\n  }\n\n  const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object) return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\n\nfunction original(value) {\n  if (!isDraft(value)) die(15, value);\n  return value[DRAFT_STATE].base_;\n}\n\nfunction each(obj, iter) {\n  if (getArchtype(obj) === 0\n  /* Object */\n  ) {\n    Reflect.ownKeys(obj).forEach(key => {\n      iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach((entry, index) => iter(index, entry, obj));\n  }\n}\n\nfunction getArchtype(thing) {\n  const state = thing[DRAFT_STATE];\n  return state ? state.type_ : Array.isArray(thing) ? 1\n  /* Array */\n  : isMap(thing) ? 2\n  /* Map */\n  : isSet(thing) ? 3\n  /* Set */\n  : 0\n  /* Object */\n  ;\n}\n\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2\n  /* Map */\n  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction get(thing, prop) {\n  return getArchtype(thing) === 2\n  /* Map */\n  ? thing.get(prop) : thing[prop];\n}\n\nfunction set(thing, propOrOldValue, value) {\n  const t = getArchtype(thing);\n  if (t === 2\n  /* Map */\n  ) thing.set(propOrOldValue, value);else if (t === 3\n  /* Set */\n  ) {\n    thing.add(value);\n  } else thing[propOrOldValue] = value;\n}\n\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction isMap(target) {\n  return target instanceof Map;\n}\n\nfunction isSet(target) {\n  return target instanceof Set;\n}\n\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\n\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n\n  if (isSet(base)) {\n    return new Set(base);\n  }\n\n  if (Array.isArray(base)) return Array.prototype.slice.call(base);\n  const isPlain = isPlainObject(base);\n\n  if (strict === true || strict === \"class_only\" && !isPlain) {\n    const descriptors = Object.getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    let keys = Reflect.ownKeys(descriptors);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const desc = descriptors[key];\n\n      if (desc.writable === false) {\n        desc.writable = true;\n        desc.configurable = true;\n      }\n\n      if (desc.get || desc.set) descriptors[key] = {\n        configurable: true,\n        writable: true,\n        // could live with !!desc.set as well here...\n        enumerable: desc.enumerable,\n        value: base[key]\n      };\n    }\n\n    return Object.create(getPrototypeOf(base), descriptors);\n  } else {\n    const proto = getPrototypeOf(base);\n\n    if (proto !== null && isPlain) {\n      return { ...base\n      };\n    }\n\n    const obj = Object.create(proto);\n    return Object.assign(obj, base);\n  }\n}\n\nfunction freeze(obj) {\n  let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n\n  if (getArchtype(obj) > 1) {\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n  if (deep) Object.entries(obj).forEach(_ref => {\n    let [key, value] = _ref;\n    return freeze(value, true);\n  });\n  return obj;\n}\n\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\n\nfunction isFrozen(obj) {\n  return Object.isFrozen(obj);\n} // src/utils/plugins.ts\n\n\nvar plugins = {};\n\nfunction getPlugin(pluginKey) {\n  const plugin = plugins[pluginKey];\n\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n\n  return plugin;\n}\n\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n} // src/core/scope.ts\n\n\nvar currentScope;\n\nfunction getCurrentScope() {\n  return currentScope;\n}\n\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_,\n    immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\n\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\");\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\n\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\n\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\n\nfunction enterScope(immer2) {\n  return currentScope = createScope(currentScope, immer2);\n}\n\nfunction revokeDraft(draft) {\n  const state = draft[DRAFT_STATE];\n  if (state.type_ === 0\n  /* Object */\n  || state.type_ === 1\n  /* Array */\n  ) state.revoke_();else state.revoked_ = true;\n} // src/core/finalize.ts\n\n\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  const baseDraft = scope.drafts_[0];\n  const isReplaced = result !== void 0 && result !== baseDraft;\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n      if (!scope.parent_) maybeFreeze(scope, result);\n    }\n\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n    }\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n\n  revokeScope(scope);\n\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n\n  return result !== NOTHING ? result : void 0;\n}\n\nfunction finalize(rootScope, value, path) {\n  if (isFrozen(value)) return value;\n  const state = value[DRAFT_STATE];\n\n  if (!state) {\n    each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path));\n    return value;\n  }\n\n  if (state.scope_ !== rootScope) return value;\n\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  }\n\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    const result = state.copy_;\n    let resultEach = result;\n    let isSet2 = false;\n\n    if (state.type_ === 3\n    /* Set */\n    ) {\n      resultEach = new Set(result);\n      result.clear();\n      isSet2 = true;\n    }\n\n    each(resultEach, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2));\n    maybeFreeze(rootScope, result, false);\n\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n    }\n  }\n\n  return state.copy_;\n}\n\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if (process.env.NODE_ENV !== \"production\" && childValue === targetObject) die(5);\n\n  if (isDraft(childValue)) {\n    const path = rootPath && parentState && parentState.type_ !== 3\n    /* Set */\n    && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n    const res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res);\n\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  }\n\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      return;\n    }\n\n    finalize(rootScope, childValue);\n    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && Object.prototype.propertyIsEnumerable.call(targetObject, prop)) maybeFreeze(rootScope, childValue);\n  }\n}\n\nfunction maybeFreeze(scope, value) {\n  let deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n} // src/core/proxy.ts\n\n\nfunction createProxyProxy(base, parent) {\n  const isArray = Array.isArray(base);\n  const state = {\n    type_: isArray ? 1\n    /* Array */\n    : 0\n    /* Object */\n    ,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  };\n  let target = state;\n  let traps = objectTraps;\n\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n\n  const {\n    revoke,\n    proxy\n  } = Proxy.revocable(target, traps);\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\n\nvar objectTraps = {\n  get(state, prop) {\n    if (prop === DRAFT_STATE) return state;\n    const source = latest(state);\n\n    if (!has(source, prop)) {\n      return readPropFromProto(state, source, prop);\n    }\n\n    const value = source[prop];\n\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(value, state);\n    }\n\n    return value;\n  },\n\n  has(state, prop) {\n    return prop in latest(state);\n  },\n\n  ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n\n  set(state, prop, value) {\n    const desc = getDescriptorFromProto(latest(state), prop);\n\n    if (desc?.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n\n    if (!state.modified_) {\n      const current2 = peek(latest(state), prop);\n      const currentState = current2?.[DRAFT_STATE];\n\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n\n    if (state.copy_[prop] === value && ( // special case: handle new props with value 'undefined'\n    value !== void 0 || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n\n  deleteProperty(state, prop) {\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      delete state.assigned_[prop];\n    }\n\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n\n    return true;\n  },\n\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor(state, prop) {\n    const owner = latest(state);\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc) return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1\n      /* Array */\n      || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n\n  defineProperty() {\n    die(11);\n  },\n\n  getPrototypeOf(state) {\n    return getPrototypeOf(state.base_);\n  },\n\n  setPrototypeOf() {\n    die(12);\n  }\n\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn) => {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop))) die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (process.env.NODE_ENV !== \"production\" && prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\n\nfunction peek(draft, prop) {\n  const state = draft[DRAFT_STATE];\n  const source = state ? latest(state) : draft;\n  return source[prop];\n}\n\nfunction readPropFromProto(state, source, prop) {\n  const desc = getDescriptorFromProto(source, prop);\n  return desc ? `value` in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the\n  // prototype, we should invoke it with the draft as context!\n  desc.get?.call(state.draft_) : void 0;\n}\n\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source)) return void 0;\n  let proto = getPrototypeOf(source);\n\n  while (proto) {\n    const desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc) return desc;\n    proto = getPrototypeOf(proto);\n  }\n\n  return void 0;\n}\n\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);\n  }\n} // src/core/immerClass.ts\n\n\nvar Immer2 = class {\n  constructor(config) {\n    var _this = this;\n\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n\n    this.produce = (base, recipe, patchListener) => {\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        const defaultBase = recipe;\n        recipe = base;\n        const self = this;\n        return function curriedProduce() {\n          let base2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBase;\n\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          return self.produce(base2, draft => recipe.call(this, draft, ...args));\n        };\n      }\n\n      if (typeof recipe !== \"function\") die(6);\n      if (patchListener !== void 0 && typeof patchListener !== \"function\") die(7);\n      let result;\n\n      if (isDraftable(base)) {\n        const scope = enterScope(this);\n        const proxy = createProxy(base, void 0);\n        let hasError = true;\n\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError) revokeScope(scope);else leaveScope(scope);\n        }\n\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === void 0) result = base;\n        if (result === NOTHING) result = void 0;\n        if (this.autoFreeze_) freeze(result, true);\n\n        if (patchListener) {\n          const p = [];\n          const ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n\n        return result;\n      } else die(1, base);\n    };\n\n    this.produceWithPatches = (base, recipe) => {\n      if (typeof base === \"function\") {\n        return function (state) {\n          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n            args[_key3 - 1] = arguments[_key3];\n          }\n\n          return _this.produceWithPatches(state, draft => base(draft, ...args));\n        };\n      }\n\n      let patches, inversePatches;\n      const result = this.produce(base, recipe, (p, ip) => {\n        patches = p;\n        inversePatches = ip;\n      });\n      return [result, patches, inversePatches];\n    };\n\n    if (typeof config?.autoFreeze === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n    if (typeof config?.useStrictShallowCopy === \"boolean\") this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n  }\n\n  createDraft(base) {\n    if (!isDraftable(base)) die(8);\n    if (isDraft(base)) base = current(base);\n    const scope = enterScope(this);\n    const proxy = createProxy(base, void 0);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  }\n\n  finishDraft(draft, patchListener) {\n    const state = draft && draft[DRAFT_STATE];\n    if (!state || !state.isManual_) die(9);\n    const {\n      scope_: scope\n    } = state;\n    usePatchesInScope(scope, patchListener);\n    return processResult(void 0, scope);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n\n\n  setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */\n\n\n  setUseStrictShallowCopy(value) {\n    this.useStrictShallowCopy_ = value;\n  }\n\n  applyPatches(base, patches) {\n    let i;\n\n    for (i = patches.length - 1; i >= 0; i--) {\n      const patch = patches[i];\n\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n\n    const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n\n    if (isDraft(base)) {\n      return applyPatchesImpl(base, patches);\n    }\n\n    return this.produce(base, draft => applyPatchesImpl(draft, patches));\n  }\n\n};\n\nfunction createProxy(value, parent) {\n  const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n  const scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n} // src/core/current.ts\n\n\nfunction current(value) {\n  if (!isDraft(value)) die(10, value);\n  return currentImpl(value);\n}\n\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value)) return value;\n  const state = value[DRAFT_STATE];\n  let copy;\n\n  if (state) {\n    if (!state.modified_) return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n  } else {\n    copy = shallowCopy(value, true);\n  }\n\n  each(copy, (key, childValue) => {\n    set(copy, key, currentImpl(childValue));\n  });\n\n  if (state) {\n    state.finalized_ = false;\n  }\n\n  return copy;\n} // src/plugins/patches.ts\n\n\nfunction enablePatches() {\n  const errorOffset = 16;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    errors.push('Sets cannot have \"replace\" patches.', function (op) {\n      return \"Unsupported patch operation: \" + op;\n    }, function (path) {\n      return \"Cannot apply patch, path doesn't resolve: \" + path;\n    }, \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\");\n  }\n\n  const REPLACE = \"replace\";\n  const ADD = \"add\";\n  const REMOVE = \"remove\";\n\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0\n      /* Object */\n      :\n      case 2\n      /* Map */\n      :\n        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n\n      case 1\n      /* Array */\n      :\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n\n      case 3\n      /* Set */\n      :\n        return generateSetPatches(state, basePath, patches, inversePatches);\n    }\n  }\n\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    let {\n      base_,\n      assigned_\n    } = state;\n    let copy_ = state.copy_;\n\n    if (copy_.length < base_.length) {\n      ;\n      [base_, copy_] = [copy_, base_];\n      [patches, inversePatches] = [inversePatches, patches];\n    }\n\n    for (let i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    }\n\n    for (let i = base_.length; i < copy_.length; i++) {\n      const path = basePath.concat([i]);\n      patches.push({\n        op: ADD,\n        path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[i])\n      });\n    }\n\n    for (let i = copy_.length - 1; base_.length <= i; --i) {\n      const path = basePath.concat([i]);\n      inversePatches.push({\n        op: REMOVE,\n        path\n      });\n    }\n  }\n\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    const {\n      base_,\n      copy_\n    } = state;\n    each(state.assigned_, (key, assignedValue) => {\n      const origValue = get(base_, key);\n      const value = get(copy_, key);\n      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE) return;\n      const path = basePath.concat(key);\n      patches.push(op === REMOVE ? {\n        op,\n        path\n      } : {\n        op,\n        path,\n        value\n      });\n      inversePatches.push(op === ADD ? {\n        op: REMOVE,\n        path\n      } : op === REMOVE ? {\n        op: ADD,\n        path,\n        value: clonePatchValueIfNeeded(origValue)\n      } : {\n        op: REPLACE,\n        path,\n        value: clonePatchValueIfNeeded(origValue)\n      });\n    });\n  }\n\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    let {\n      base_,\n      copy_\n    } = state;\n    let i = 0;\n    base_.forEach(value => {\n      if (!copy_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path,\n          value\n        });\n      }\n\n      i++;\n    });\n    i = 0;\n    copy_.forEach(value => {\n      if (!base_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path,\n          value\n        });\n      }\n\n      i++;\n    });\n  }\n\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n\n  function applyPatches_(draft, patches) {\n    patches.forEach(patch => {\n      const {\n        path,\n        op\n      } = patch;\n      let base = draft;\n\n      for (let i = 0; i < path.length - 1; i++) {\n        const parentType = getArchtype(base);\n        let p = path[i];\n\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n\n        if ((parentType === 0\n        /* Object */\n        || parentType === 1\n        /* Array */\n        ) && (p === \"__proto__\" || p === \"constructor\")) die(errorOffset + 3);\n        if (typeof base === \"function\" && p === \"prototype\") die(errorOffset + 3);\n        base = get(base, p);\n        if (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"));\n      }\n\n      const type = getArchtype(base);\n      const value = deepClonePatchValue(patch.value);\n      const key = path[path.length - 1];\n\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            case 3\n            /* Set */\n            :\n              die(errorOffset);\n\n            default:\n              return base[key] = value;\n          }\n\n        case ADD:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            case 3\n            /* Set */\n            :\n              return base.add(value);\n\n            default:\n              return base[key] = value;\n          }\n\n        case REMOVE:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return base.splice(key, 1);\n\n            case 2\n            /* Map */\n            :\n              return base.delete(key);\n\n            case 3\n            /* Set */\n            :\n              return base.delete(patch.value);\n\n            default:\n              return delete base[key];\n          }\n\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj)) return obj;\n    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(_ref2 => {\n      let [k, v] = _ref2;\n      return [k, deepClonePatchValue(v)];\n    }));\n    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n    const cloned = Object.create(getPrototypeOf(obj));\n\n    for (const key in obj) cloned[key] = deepClonePatchValue(obj[key]);\n\n    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else return obj;\n  }\n\n  loadPlugin(\"Patches\", {\n    applyPatches_,\n    generatePatches_,\n    generateReplacementPatches_\n  });\n} // src/plugins/mapset.ts\n\n\nfunction enableMapSet() {\n  class DraftMap extends Map {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 2\n        /* Map */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false\n      };\n    }\n\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n\n    has(key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    }\n\n    set(key, value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n      }\n\n      return this;\n    }\n\n    delete(key) {\n      if (!this.has(key)) {\n        return false;\n      }\n\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n\n      state.copy_.delete(key);\n      return true;\n    }\n\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = /* @__PURE__ */new Map();\n        each(state.base_, key => {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    }\n\n    forEach(cb, thisArg) {\n      const state = this[DRAFT_STATE];\n      latest(state).forEach((_value, key, _map) => {\n        cb.call(thisArg, this.get(key), key, this);\n      });\n    }\n\n    get(key) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      const value = latest(state).get(key);\n\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n\n      if (value !== state.base_.get(key)) {\n        return value;\n      }\n\n      const draft = createProxy(value, state);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    }\n\n    keys() {\n      return latest(this[DRAFT_STATE]).keys();\n    }\n\n    values() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.values(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done) return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value\n          };\n        }\n      };\n    }\n\n    entries() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.entries(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done) return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value: [r.value, value]\n          };\n        }\n      };\n    }\n\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.entries();\n    }\n\n  }\n\n  function proxyMap_(target, parent) {\n    return new DraftMap(target, parent);\n  }\n\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n\n  class DraftSet extends Set {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 3\n        /* Set */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: this,\n        drafts_: /* @__PURE__ */new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n    }\n\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n\n    has(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n\n      if (state.copy_.has(value)) return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n      return false;\n    }\n\n    add(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n      }\n\n      return this;\n    }\n\n    delete(value) {\n      if (!this.has(value)) {\n        return false;\n      }\n\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :\n      /* istanbul ignore next */\n      false);\n    }\n\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    }\n\n    values() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    }\n\n    entries() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    }\n\n    keys() {\n      return this.values();\n    }\n\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.values();\n    }\n\n    forEach(cb, thisArg) {\n      const iterator = this.values();\n      let result = iterator.next();\n\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    }\n\n  }\n\n  function proxySet_(target, parent) {\n    return new DraftSet(target, parent);\n  }\n\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */new Set();\n      state.base_.forEach(value => {\n        if (isDraftable(value)) {\n          const draft = createProxy(value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n\n  function assertUnrevoked(state) {\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\n  }\n\n  loadPlugin(\"MapSet\", {\n    proxyMap_,\n    proxySet_\n  });\n} // src/immer.ts\n\n\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\n\nfunction castDraft(value) {\n  return value;\n}\n\nfunction castImmutable(value) {\n  return value;\n}\n\nexport { Immer2 as Immer, applyPatches, castDraft, castImmutable, createDraft, current, enableMapSet, enablePatches, finishDraft, freeze, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseStrictShallowCopy };","map":{"version":3,"mappings":"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","names":["NOTHING","Symbol","for","DRAFTABLE","DRAFT_STATE","errors","process","env","NODE_ENV","plugin","thing","data","die","error","e","args","msg","apply","Error","getPrototypeOf","Object","isDraft","value","isDraftable","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","prototype","toString","proto","Ctor","hasOwnProperty","call","Function","original","base_","each","obj","iter","getArchtype","Reflect","ownKeys","forEach","key","entry","index","state","type_","has","prop","get","set","propOrOldValue","t","add","is","x","y","target","Map","Set","latest","copy_","shallowCopy","base","strict","slice","isPlain","descriptors","getOwnPropertyDescriptors","keys","i","length","desc","writable","configurable","enumerable","create","assign","freeze","deep","isFrozen","clear","delete","dontMutateFrozenCollections","entries","plugins","getPlugin","pluginKey","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","path","childValue","finalizeProperty","scope_","finalized_","resultEach","generatePatches_","parentState","targetObject","rootPath","targetIsSet","assigned_","concat","res","autoFreeze_","propertyIsEnumerable","createProxyProxy","parent","draft_","isManual_","traps","objectTraps","arrayTraps","revoke","proxy","Proxy","revocable","source","readPropFromProto","peek","prepareCopy","createProxy","getDescriptorFromProto","current","currentState","markChanged","Number","isNaN","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","setPrototypeOf","fn","arguments","parseInt","useStrictShallowCopy_","Immer","config","recipe","defaultBase","self","curriedProduce","produce","hasError","p","ip","produceWithPatches","patches","inversePatches","autoFreeze","setAutoFreeze","useStrictShallowCopy","setUseStrictShallowCopy","createDraft","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","proxyMap_","proxySet_","push","currentImpl","copy","enablePatches","errorOffset","REPLACE","ADD","REMOVE","basePath","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","clonePatchValueIfNeeded","assignedValue","origValue","unshift","baseValue","replacement","parentType","join","type","deepClonePatchValue","splice","map","from","k","v","cloned","enableMapSet","DraftMap","size","assertUnrevoked","prepareMapCopy","cb","thisArg","_value","_map","values","iterator","next","r","done","DraftSet","prepareSetCopy","JSON","stringify","bind","castDraft","castImmutable"],"sources":["/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/utils/env.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/utils/errors.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/utils/common.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/utils/plugins.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/core/scope.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/core/finalize.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/core/proxy.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/core/immerClass.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/core/current.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/plugins/patches.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/plugins/mapset.ts","/Users/Yasin.Gulamhussain.Admin/Ecommerce-Project/node_modules/immer/src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","export const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n * Regardless whether they are enumerable or symbols\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tReflect.ownKeys(obj).forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: Array.isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc.writable === false) {\n\t\t\t\tdesc.writable = true\n\t\t\t\tdesc.configurable = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\t\tvalue: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn Object.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = Object.create(proto)\n\t\treturn Object.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.entries (only string-like, enumerables) instead of each()\n\t\tObject.entries(obj).forEach(([key, value]) => freeze(value, true))\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(value, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path)\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result = state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\t// And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\ttargetObject.add(childValue)\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// Immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\t// Per #590, we never freeze symbolic properties. Just to make sure don't accidentally interfere\n\t\t// with other frameworks.\n\t\tif (\n\t\t\t(!parentState || !parentState.scope_.parent_) &&\n\t\t\ttypeof prop !== \"symbol\" &&\n\t\t\tObject.prototype.propertyIsEnumerable.call(targetObject, prop)\n\t\t)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\";\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t}) {\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(copy, (key, childValue) => {\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\")\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n"]},"metadata":{},"sourceType":"module"}